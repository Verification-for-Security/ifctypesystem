-- This module includes the datatypes for Nano and Function. DO NOT EDIT THIS FILE.



module Nano
  ( Nano
  , Function (..)
  , Statement (..)
  , skip
  , seq
  ) where

import Prelude hiding (and, or, seq)
import Expr
import Logic

-- | A full Nano program.
type Nano a = [Function a]

-- | A function in Nano
data Function a = Function
  { fname :: !a
  -- ^ Function name
  , fargs :: ![a]
  -- ^ Function arguments
  , ftypes :: ![(a, String)]
  -- ^ Types of the variables
  , fhasse :: ![(String, String)]
  -- ^ Used only by the special Hasse function
  -- Stores the order of the types
  , fbody :: !(Statement a)
  -- ^ Function body
  , freturn :: [Expr a]
  -- ^ What the function returns. This is kind of hacky, but it should be fine. It stores the returned expression as a singleton list
  -- We will assume all Nano function can only return a single expression at the end of a function
  }
  deriving (Eq, Ord, Show)

-- | Nano statement
data Statement a
  = Seq ![Statement a]
  -- ^ body0; body1; ... bodyN;
  | If !(Logic a) !(Statement a) !(Statement a)
  -- ^ If conditional body0 body1
  | While !(Logic a) !(Statement a)
  -- ^ While invariant conditional body
  | Return !(Expr a)
  -- ^ Return expr
  | Assume !(Logic a)
  -- ^ Assume pred
  | Assert !(Logic a)
  -- ^ Assert pred
  | Assign !a !(Expr a)
  -- ^ x := e
  | ArrAsn !a !(Expr a) !(Expr a)
  -- ^ x[i] := e
  | AppAsn !a !a ![Expr a]
  -- ^ x := f(e0, .., eN)
  deriving (Eq, Ord, Show)

instance Semigroup (Statement a) where
  lhs <> rhs = seq [lhs, rhs]

instance Monoid (Statement a) where
  mempty = skip

-- | Skip; essentially a No-Op
skip :: Statement a
skip = Seq []

-- | Seq (removes nested sequences)
seq :: [Statement a] -> Statement a
seq = unflatten . mconcat . (flatten <$>)
  where
    unflatten [s] = s
    unflatten s = Seq s

    flatten (Seq s) = s
    flatten s = [s]

