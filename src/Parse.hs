-- This module parses Javascript code into Nano. DO NOT EDIT THIS FILE.


module Parse
  ( Constraints
  , nano
  , function
  , statement
  , logic
  , predicate
  , expr
  ) where

import qualified Language.ECMAScript3.Syntax as JS
import qualified Language.ECMAScript3.Parser as JS
import Data.Composition

import Control.Monad.State
import Control.Applicative (empty, Alternative)
import Prelude hiding (seq, and, or)

import Expr
import Logic
import Nano


data Constraints a = Constraints
  { types :: ![(a, String)]
  , hasse :: ![(String, String)]
  , returns :: ![Expr a]
  }
  deriving (Show, Eq, Ord)

instance Semigroup (Constraints a) where
  Constraints t h rs <> Constraints t' h' rs'
    = Constraints (t <> t') (h <> h') (rs <> rs')

instance Monoid (Constraints a) where
  mempty = Constraints mempty mempty mempty

type MonadNano a m = (MonadState (Constraints a) m, Alternative m)

-- | Parses Javascript and converts it into Nano.
nano :: String -> IO (Maybe (Nano String))
nano path = do
  JS.Script _ stmts <- JS.parseFromFile path
  return $ mapM function stmts

-- | Converts a JS function statement into a function.
function :: JS.Statement a -> Maybe (Function String)
function (JS.FunctionStmt _ (JS.Id _ name) args body) = do
  (body', constraints) <- flip runStateT mempty $ mapM statement body
  let args' = (\(JS.Id _ v) -> v) <$> args
  return $ Function 
    { fname = name
    , fargs = args'
    , ftypes = types constraints
    , fbody = seq body'
    , fhasse = hasse constraints
    , freturn = returns constraints
    }
function _ = empty

-- | Converts JS into Nano.
--
-- This should convert the following subset of JS into Nano statements:
-- - Empty statement
-- - Return
-- - Assignments, Nano has three types of assignments:
--   - x := f(e0, .., eN)
--   - x := expr
--   - arr[i] := expr
-- - Variable declaration (only when it assigns a value)
-- - Block statement
-- - If statement (with and without else)
-- - While statement 
-- 


statement :: MonadNano String m => JS.Statement a -> m (Statement String)
statement = \case
  EmptyStmt -> return skip

  ReturnStmt e -> do
    e' <- expr e
    addReturn e'
    return $ Return e'

  AssignStmt var (Call name args) -> do
    args' <- mapM expr args
    return $ AppAsn var name args'

  AssignStmt var rhs -> do
    expr' <- expr rhs
    return $ Assign var expr'

  ArrAsnStmt var index rhs -> do
    index' <- expr index
    expr' <- expr rhs
    return $ ArrAsn var index' expr'

  DeclStmt ss -> seq <$> mapM decls ss
    where
      decls = \case
        Decl var e -> Assign var <$> expr e
        _ -> empty

  BlockStmt ss -> seq <$> mapM statement ss

  IfSingleStmt cond body -> do
    cond' <- logic cond
    body' <- statement body
    return $ If cond' body' skip
  
  IfStmt cond body0 body1 -> do
    cond' <- logic cond
    body0' <- statement body0
    body1' <- statement body1
    return $ If cond' body0' body1'

  WhileStmt cond body -> do
    cond' <- logic cond
    body' <- statement body
    return $ While cond' body'
  CallStmt "type" [Variable v, String s] -> do
    addType (v,s)
    return skip
  CallStmt "hasseedge" [String s1, String s2] -> do
    addHasse (s1,s2)
    return skip

  _ -> empty

-- | Helper function to scope invariant fetching to a block.
--


addType :: MonadNano a m => (a, String) -> m ()
addType x = modify (mempty { types = [x] } <>)

addHasse :: MonadNano a m => (String, String) -> m ()
addHasse x = modify (mempty { hasse = [x] } <>)

addReturn :: MonadNano a m => Expr a -> m ()
addReturn x = modify (mempty { returns = [x] } <>)


-- | Converts JS into Nano logic.
--
-- This should convert the following subset of JS into Nano expressions:
-- - Boolean literals
-- - Conjuncts and Disjuncts
-- - Negation
-- - Functions called "forall" or "exists" with two arguments (of which the
--   first a variable) into its respective quantifier. 
-- - Remaining expressions should be parsed as predicates
--

logic :: (Monad m, Alternative m) => JS.Expression a -> m (Logic String)
logic = \case
  Bool b | b -> return true
  Bool b | not b -> return false
  InfixExpr lhs JS.OpLAnd rhs -> do
    lhs' <- logic lhs
    rhs' <- logic rhs
    return $ and [lhs', rhs']
  InfixExpr lhs JS.OpLOr rhs -> do
    lhs' <- logic lhs
    rhs' <- logic rhs
    return $ or [lhs', rhs']
  Negate e -> neg <$> logic e
  Call name [Variable x, l] -> do
    quantifier <- case name of
      "forall" -> return Forall
      "exists" -> return exists
      _ -> empty

    l' <- logic l
    return $ quantifier x l'
  p -> predicate p

-- | Converts JS into Nano expressions of type Bool
--
-- This should convert the following subset of JS into Nano expressions:
-- - All (strict) (in)equalities (i.e. ==, !=, >=, <=, >, <)
-- - `empty` for remaining patterns.
--
-- Notice that the return value of this function is not actually of type Pred,
-- but of type Logic. This is because we express some of the operations via a
-- negation of a predicate. I.e. `x < y` is equivalent to `~(x >= y)`.
-- The operands are expressions and should be parsed as such.
--
predicate :: (Monad m, Alternative m) => JS.Expression a -> m (Logic String)
predicate (InfixExpr lhs op rhs) = do
  op' <- case op of
    JS.OpLEq -> return $ Pred .* flip (:>=:)
    JS.OpGEq -> return $ Pred .* (:>=:)
    JS.OpEq -> return $ Pred .* (:==:)
    JS.OpGT -> return $ Neg . Pred .* flip (:>=:)
    JS.OpLT -> return $ Neg . Pred .* (:>=:)
    JS.OpNEq -> return $ Neg . Pred .* (:==:)
    _ -> empty

  lhs' <- expr lhs
  rhs' <- expr rhs
  return $ lhs' `op'` rhs'
predicate _ = empty

-- | Converts JS into Nano expressions of type Int.
--
-- This should convert the following subset of JS into Nano expressions:
-- - Integer literals
-- - Variables
-- - Array indexing
-- - Binary arithmetic (only those supported by Nano)
-- - Unary minus
-- - Some bitwise operations

expr :: (Monad m, Alternative m) => JS.Expression a -> m (Expr String)
expr = \case
  Int i -> return . Const $ fromIntegral i
  Variable name -> return $ Var (name :@ 0)
  ArrayIndex array index -> do
    array' <- expr array
    index' <- expr index
    return $ Select array' index'
  Minus e -> BinOp Sub (Const 0) <$> expr e
  InfixExpr lhs op rhs -> do
    op' <- case op of
      JS.OpAdd -> return Add
      JS.OpSub -> return Sub
      JS.OpMul -> return Mul
      JS.OpDiv -> return Div
      JS.OpMod -> return Mod
      JS.OpBOr -> return BitOr
      JS.OpBAnd -> return BitAnd
      JS.OpBXor -> return BitXor
      JS.OpLShift -> return LShift
      JS.OpSpRShift -> return RShiftSign
      JS.OpZfRShift -> return RShiftZero
      _ -> empty

    lhs' <- expr lhs
    rhs' <- expr rhs
    return $ BinOp op' lhs' rhs'
  _ -> empty

pattern Variable :: String -> JS.Expression a
pattern Variable x <- JS.VarRef _ (JS.Id _ x)

pattern Int :: Int -> JS.Expression a
pattern Int i <- JS.IntLit _ i

pattern String :: String -> JS.Expression as
pattern String s <- JS.StringLit _ s

pattern Bool :: Bool -> JS.Expression a
pattern Bool b <- JS.BoolLit _ b

pattern Minus :: JS.Expression a -> JS.Expression a
pattern Minus e <- JS.PrefixExpr _ JS.PrefixMinus e

pattern Negate :: JS.Expression a -> JS.Expression a
pattern Negate e <- JS.PrefixExpr _ JS.PrefixLNot e

pattern ArrayIndex :: JS.Expression a -> JS.Expression a -> JS.Expression a
pattern ArrayIndex array index <- JS.BracketRef _ array index

pattern InfixExpr :: JS.Expression a -> JS.InfixOp -> JS.Expression a -> JS.Expression a
pattern InfixExpr lhs op rhs <- JS.InfixExpr _ op lhs rhs

pattern Call :: String -> [JS.Expression a] -> JS.Expression a
pattern Call name arguments <- JS.CallExpr _ (Variable name) arguments

pattern CallStmt :: String -> [JS.Expression a] -> JS.Statement a
pattern CallStmt name arguments <- JS.ExprStmt _ (Call name arguments)

pattern WhileStmt :: JS.Expression a -> JS.Statement a -> JS.Statement a
pattern WhileStmt conditional body <- JS.WhileStmt _ conditional body

pattern IfStmt :: JS.Expression a -> JS.Statement a -> JS.Statement a -> JS.Statement a
pattern IfStmt conditional body0 body1 <- JS.IfStmt _ conditional body0 body1

pattern IfSingleStmt :: JS.Expression a -> JS.Statement a -> JS.Statement a
pattern IfSingleStmt conditional body <- JS.IfSingleStmt _ conditional body

pattern BlockStmt :: [JS.Statement a] -> JS.Statement a
pattern BlockStmt body <- JS.BlockStmt _ body

pattern EmptyStmt :: JS.Statement a
pattern EmptyStmt <- JS.EmptyStmt _

pattern ReturnStmt :: JS.Expression a -> JS.Statement a
pattern ReturnStmt expr <- JS.ReturnStmt _ (Just expr)

-- | This is a helper for the other assign statements, you do not have to use
-- this directly.
pattern AssignStmt' :: JS.LValue a -> JS.Expression a -> JS.Statement a
pattern AssignStmt' lhs rhs <- JS.ExprStmt _ (JS.AssignExpr _ JS.OpAssign lhs rhs)

-- | You still have to distinguish between an expression or function call on
-- the rhs when using this pattern.
pattern AssignStmt :: String -> JS.Expression a -> JS.Statement a
pattern AssignStmt var rhs <- AssignStmt' (JS.LVar _ var) rhs

pattern ArrAsnStmt :: String -> JS.Expression a -> JS.Expression a -> JS.Statement a
pattern ArrAsnStmt array index rhs <- AssignStmt' (JS.LBracket _ (Variable array) index) rhs

pattern DeclStmt :: [JS.VarDecl a] -> JS.Statement a
pattern DeclStmt statements <- JS.VarDeclStmt _ statements

pattern Decl :: String -> JS.Expression a -> JS.VarDecl a
pattern Decl var expr <- JS.VarDecl _ (JS.Id _ var) (Just expr)
